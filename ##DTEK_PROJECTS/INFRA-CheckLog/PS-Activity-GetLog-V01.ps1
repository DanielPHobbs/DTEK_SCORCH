# Set script parameters from runbook data bus and Orchestrator global variables
# Define any inputs here and then add to the $argsArray and script block parameters below 

$DataBusInput1 = "{Parameter 1 from Initialize Data}"
$DataBusInput2 = "{Global Variable 1}"
$ComputerName = "dtekaz-hw01.dtek.com"

#-----------------------------------------------------------------------

## Initialize result and trace variables
# $ResultStatus provides basic success/failed indicator
# $ErrorMessage captures any error text generated by script
# $Trace is used to record a running log of actions
$ResultStatus = ""
$ErrorMessage = ""
$Trace = (Get-Date).ToString() + "`t" + "Runbook activity script started" + " `r`n"
       

    # Define function to add entry to trace log variable
    function AppendLog ([string]$Message)
    {
        $script:CurrentAction = $Message
        $script:TraceLog += ((Get-Date).ToString() + "`t" + $Message + " `r`n")
    }

    # Set session trace and status variables to defaults
    $ResultStatus = ""
    $ErrorMessage = ""
    $script:CurrentAction = ""
    $script:TraceLog = ""

    try 
    {
        # Add startup details to trace log
        AppendLog "Script now executing in external PowerShell version [$($PSVersionTable.PSVersion.ToString())] session in a [$([IntPtr]::Size * 8)] bit process"
        AppendLog "Running as user [$([Environment]::UserDomainName)\$([Environment]::UserName)] on host [$($env:COMPUTERNAME)]"
        AppendLog "Parameter values received: DataBusInput1=[$DataBusInput1]; DataBusInput2=[$DataBusInput2]"

        ##################################################### MAIN CODE ##################################################################

        
        AppendLog "Entering session to get Logs"
        $logtext=Invoke-Command -computername $computerName  -ScriptBlock { Get-Content F:\inetpub\logs\logfiles\W3SVC1\u_ex210414.log -tail 5} 
        
        $EverythingWorked="true"
        ###################################################################################################################################

        # Validate results and set return status
        AppendLog "Finished work, determining result"
        $EverythingWorked = $true
        if($EverythingWorked -eq $true)
        {
           $ResultStatus = "Success"
        }
        else
        {
            $ResultStatus = "Failed"
        }
    }
    catch
    {
        # Catch any errors thrown above here, setting the result status and recording the error message to return to the activity for data bus publishing
        $ResultStatus = "Failed"
        $ErrorMessage = $error[0].Exception.Message
        AppendLog "Exception caught during action [$script:CurrentAction]: $ErrorMessage"
    }
    finally
    {
        # Always do whatever is in the finally block. In this case, adding some additional detail about the outcome to the trace log for return
        if($ErrorMessage.Length -gt 0)
        {
            AppendLog "Exiting session with result [$ResultStatus] and error message [$ErrorMessage]"
        }
        else
        {
            AppendLog "Exiting session with result [$ResultStatus]"
        }
        
    }

# Record end of activity script process
AppendLog  "Script finished" 


<#
Name	                    Type	    Variable	    Is Collection
Result Status	            String	    ResultStatus	false
Error Message	            String	    ErrorMessage	false
Trace Log	                String	    TraceLog	    false
logcontent              	Array	    logcontent 	    $true
#>

#$Tracelog
#$errormessage
#$logtext.gettype()

#$LogLine = [System.Collections.ArrayList]::new()
#[void]$logline.Add($logtext.foreach{"Item [$PSItem]"})

#$LogLine.GetType()
#$logline

#$logcontent += $logtext.foreach{"Item [$PSItem]"}
#$logcontent

#foreach ($item in $logtext){[STRING]$logline=$item;$logline}


foreach ($item in $logtext.Split("`n")){
    
    [STRING]$logline =$item
    #$logline
    }
#$logline=$logline.Split("`n")
#$logline